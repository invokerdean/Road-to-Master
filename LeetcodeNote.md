# 1.数独问题
> 每行每列每个九宫格需要有不重复的1-9

#### 36.验证已填部分是否符合规则
思路：
1. 建立三个二维9x9数组标记行列子九宫格的的1-9是否已经出现
2. 循环遍历输入的二维数组，对于每个字符元素，转换为1中对应数组的坐标，其中，子九宫格的坐标：i/3*3+j/3
3. 判断当前(i,j,k)的数字是否已经出现过，是则返回false，否则将三个标记数组中对应的坐标置为1
4.循环结束返回true
```C++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int used1[9][9]={0},used2[9][9]={0},used3[9][9]={0};
        for(int i=0;i<board.size();i++){
            for(int j=0;j<board[i].size();j++){
                if(board[i][j]!='.'){
                    int num=board[i][j]-'0'-1,k=i/3*3+j/3;
                    if(used1[i][num]||used2[j][num]||used3[k][num]) return false;
                    used1[i][num]=used2[j][num]=used3[k][num]=1;
                }
            }
        }
        return true;
    }
};
```
# 2.全排列
> 全排列的含义就是一个序列所有的排序可能性，那么我们现在做这样的一个假设，假设给定的一些序列中第一位都不相同，那么就可以认定说这些序列一定不是同一个序列，这是一个很显然的问题。有了上面的这一条结论，我们就可以同理得到如果在第一位相同，可是第二位不同，那么在这些序列中也一定都不是同一个序列，这是由上一条结论可以获得的。

> 我们获得了在第一个位置上的所有情况之后，抽去序列T中的第一个位置，那么对于剩下的序列可以看成是一个全新的序列T1，序列T1可以认为是与之前的序列毫无关联了。同样的，我们可以对这个T1进行与T相同的操作，直到T中只一个元素为止。这样我们就获得了所有的可能性。所以很显然，这是一个递归算法。
