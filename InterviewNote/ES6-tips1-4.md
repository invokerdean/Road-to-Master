## 1.let 和 const：
#### let：
不存在变量提升，暂时性死区，let不允许重复声明
#### 块级作用域：
ES5只有全局作用域和函数作用域：
1. 在条件判断语句内声明内部变量，由于变量提升内层变量可能会覆盖外层变量
2. 用来计数的循环变量泄露为全局变量

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

ES6 的块级作用域必须有大括号
#### const:
const声明的变量不得改变值，const一旦声明变量，就必须立即初始化，不能留到以后赋值,
const命令声明的常量也是不提升，同样存在暂时性死区,不可重复声明
>本质：const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动,如果真的想将对象冻结，应该使用Object.freeze方法:
const foo = Object.freeze({});

var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
## 2.解构赋值
#### 数组的解构赋值
只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
`let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3`
解构赋值允许指定默认值。ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。
#### 对象的解构赋值
对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果变量名与属性名不一致，必须写成下面这样。
`
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
`
这说明对象的解构赋值是下面形式的简写（
`
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };`
foo是匹配的模式，baz才是变量

对象的解构赋值可以取到继承的属性。
`
const obj1 = {};
const obj2 = { foo: 'bar' };
Object.setPrototypeOf(obj1, obj2);
const { foo } = obj1;
foo // "bar"`

#### 字符串的解构赋值
字符串被转换成了一个类似数组的对象。
#### 数值和布尔值的解构赋值
解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
函数的参数也可以使用解构赋值。
####圆括号问题
ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。
但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。
可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。

## 3.字符串扩展
#### 字符的Unicode表示（这部分还不甚理解）
过去：\uxxxx形式表示一个字符,只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。对于"\u20BB7"JavaScript 会理解成\u20BB+7
ES6:只要将码点放入大括号，就能正确解读该字符。
#### 遍历器接口，可以用for...of循环
这个遍历器最大的优点是可以识别大于0xFFFF的码点，for循环会认为它包含两个字符（都不可打印），而for...of循环会正确识别出这一个字符。
#### 模板字符串
模板字符串（template string）是增强版的字符串，用反引号（`）(`)标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
模板字符串中嵌入变量，需要将变量名写在${}之中。所有模板字符串的空格和换行，都是被保留的，如果你不想要这个换行，可以使用trim方法消除它。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性，还能调用函数。模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。如果不是字符串，将按照一般的规则转为字符串
#### 模板编译（没看懂，略过）
#### 标签模板
标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。
如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。
```
let a = 5;
let b = 10;

tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag(['Hello ', ' world ', ''], 15, 50);
```
tag函数所有参数的实际值如下。

第一个参数：['Hello ', ' world ', '']
第二个参数: 15
第三个参数：50
也就是说，tag函数实际上以下面的形式调用。

tag(['Hello ', ' world ', ''], 15, 50)
###### 标签模板的应用：
1.就是过滤 HTML 字符串，防止用户输入恶意内容。针对${sender}中用户发送的部分，定义一个函数将特殊字符进行转义
2.多语言转换（国际化处理）
3.你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。
模板处理函数的第一个参数（模板字符串数组），还有一个raw属性，保存的是转义后的原字符串。这是为了方便取得转义之前的原始模板而设计的。
## 4.字符串新增方法
#### String.fromCodePoint() 
ES5:String.fromCharCode(),从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。
ES6:String.fromCodePoint()方法，可以识别大于0xFFFF的字符
#### String.raw()
该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。
```
String.raw`Hi\\n`
// 返回 "Hi\\\\n"
```
#### 实例方法：codePointAt()
JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。
```
var s = "𠮷";

s.length // 2
s.charAt(0) // ''
s.charAt(1) // ''
s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271
```
codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。
```
let s = '𠮷a';

s.codePointAt(0) // 134071
s.codePointAt(1) // 57271

s.codePointAt(2) // 97
```
codePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。
```
let s = '𠮷a';

s.codePointAt(0).toString(16) // "20bb7"
s.codePointAt(2).toString(16) // "61"
```
解决第二个字符坐标问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 UTF-16 字符。另一种方法也可以，使用扩展运算符（...）进行展开运算。
codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。
```
function is32Bit(c) {
  return c.codePointAt(0) > 0xFFFF;
}
```
#### 实例方法：normalize()
用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。(略过)
#### 实例方法：includes(), startsWith(), endsWith()
用来确定一个字符串是否包含在另一个字符串中
1. ES5:indexOf
2. ES6新增了三种
* includes()：返回布尔值，表示是否找到了参数字符串。
* startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
* endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
三种方法都支持第二个参数，表示开始搜索的位置。使用第二个参数n时，endsWith的行为与其他两个方法有所不同，它针对前n个字符
#### 实例方法：repeat()
repeat方法返回一个新字符串，表示将原字符串重复n次。（0次为空，参数是负数或者Infinity，会报错。）对于小数，会先进行取整运算，参数NaN等同于 0。字符串则会先转换成数字。
#### 实例方法：padStart()，padEnd()
字符串补全长度的功能，如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。
第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。
```
'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'

'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'
```
如果省略第二个参数，默认使用空格补全长度。这些方法的常见用途是为数值补全指定位数，另一个用途是提示字符串格式。
```
'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
```
#### 实例方法：trimStart()，trimEnd()
trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。
```
const s = '  abc  ';

s.trim() // "abc"
s.trimStart() // "abc  "
s.trimEnd() // "  abc"
```
除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。

浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。
