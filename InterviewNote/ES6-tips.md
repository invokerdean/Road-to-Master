## 1.let 和 const：
#### let：
不存在变量提升，暂时性死区，let不允许重复声明
#### 块级作用域：
ES5只有全局作用域和函数作用域：
1. 在条件判断语句内声明内部变量，由于变量提升内层变量可能会覆盖外层变量
2. 用来计数的循环变量泄露为全局变量

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

ES6 的块级作用域必须有大括号
#### const:
const声明的变量不得改变值，const一旦声明变量，就必须立即初始化，不能留到以后赋值,
const命令声明的常量也是不提升，同样存在暂时性死区,不可重复声明
>本质：const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动,如果真的想将对象冻结，应该使用Object.freeze方法:
const foo = Object.freeze({});

var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
## 2.解构赋值
#### 数组的解构赋值
只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
`let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3`
解构赋值允许指定默认值。ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。
#### 对象的解构赋值
对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果变量名与属性名不一致，必须写成下面这样。
`
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
`
这说明对象的解构赋值是下面形式的简写（
`
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };`
foo是匹配的模式，baz才是变量

对象的解构赋值可以取到继承的属性。
`
const obj1 = {};
const obj2 = { foo: 'bar' };
Object.setPrototypeOf(obj1, obj2);
const { foo } = obj1;
foo // "bar"`

#### 字符串的解构赋值
字符串被转换成了一个类似数组的对象。
#### 数值和布尔值的解构赋值
解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
函数的参数也可以使用解构赋值。
####圆括号问题
ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。
但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。
可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。

## 字符串扩展
#### 模板字符串
模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
模板字符串中嵌入变量，需要将变量名写在${}之中。所有模板字符串的空格和换行，都是被保留的，如果你不想要这个换行，可以使用trim方法消除它。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性，还能调用函数。
